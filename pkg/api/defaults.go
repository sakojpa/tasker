package api

import (
	"crypto/rand"
	"encoding/json"
	"fmt"
	db "github.com/sakojpa/tasker/pkg/database"
	"log"
	"net/http"
	"time"
)

var (
	dateFormat = "20060102"
)

// TasksResp represents a list of tasks returned in API responses.
type TasksResp struct {
	Tasks []*db.Task `json:"tasks"`
}

// AuthRequest represents request body for authentication endpoint.
type AuthRequest struct {
	Password string `json:"password"`
}

// AuthResp represents response body for authentication endpoint.
type AuthResp struct {
	Token string `json:"token"`
}

// afterNow checks if the given date is strictly after today's date, ignoring time within the day.
func afterNow(d1, d2 time.Time) bool {
	return d1.Truncate(24 * time.Hour).After(d2.Truncate(24 * time.Hour))
}

// getLastDayOfMonth returns the last day of the specified month and year.
func getLastDayOfMonth(month time.Month, year int) time.Time {
	return time.Date(year, month+1, 0, 0, 0, 0, 0, time.UTC)
}

// checkDaysEquality compares two dates according to a specific format and returns their equality result.
func checkDaysEquality(d1, d2 time.Time, format string) bool {
	return d1.Format(format) == d2.Format(format)
}

// sentErrorJson sends an HTTP response with an error message in JSON format.
func sentErrorJson(w http.ResponseWriter, message string, code int) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(code)
	response := map[string]string{"error": message}
	err := json.NewEncoder(w).Encode(response)
	if err != nil {
		fmt.Errorf("marshaller error")
		return
	}
}

var secretKey []byte

// Formats represents available output formats for processed data.
const (
	Json Format = iota + 1
	Plain
)

// Format is an alias for 'int', used to store formatting type identifiers.
// Possible values:
// 1: Json
// 2: Plain
type Format int

// SecretKey initializes with randomly generated bytes of length 256.
func init() {
	secretKey = genSecretKey(256)
}

// genSecretKey generates a random secret key of specified length.
func genSecretKey(length int) []byte {
	key := make([]byte, length)
	if _, err := rand.Read(key); err != nil {
		log.Fatalf("Key generate error: %v", err)
	}
	return key
}

// sentOkMsg sends successful HTTP response with data in requested format (JSON or plain text).
func sentOkMsg(w http.ResponseWriter, data interface{}, output Format) {
	switch output {
	case Json:
		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		err := json.NewEncoder(w).Encode(data)
		if err != nil {
			fmt.Errorf("marshaller error")
			return
		}
	case Plain:
		w.Header().Set("Content-Type", "text/plain; charset=UTF-8")
		fmt.Fprintf(w, "%s", data)
	}
}
